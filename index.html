<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dark Academia Pomodoro Timer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <!-- Removed: <script src="https://cdn.jsdelivr.net/npm/tone@14.7.58/build/Tone.min.js"></script> -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles to match the Dark Academia aesthetic */
        body {
            font-family: 'Cormorant Garamond', serif;
            color: #E2D9C3; /* Off-white text, used as the new warm beige button text colour */
            background-color: #2C241E; /* Very dark brown background */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scroll-bars */
        }
        .timer-container {
            background-color: rgba(30, 25, 20, 0.7); /* Dark, semi-transparent background */
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 2.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 400px;
            width: 100%;
            text-align: center;
            border: 1px solid rgba(226, 217, 195, 0.1);
            backdrop-filter: blur(5px);
            position: relative; /* Needed for absolute positioning of corners */
        }
        /* Corner elements for aesthetic */
        .timer-container::before,
        .timer-container::after {
            content: '';
            position: absolute;
            width: 30px;
            height: 30px;
            border: 4px solid #586F5C; /* Green border colour */
            pointer-events: none;
            border-radius: 5px;
        }
        .timer-container::before {
            top: -2px;
            left: -2px;
            border-bottom: none;
            border-right: none;
        }
        .timer-container::after {
            bottom: -2px;
            right: -2px;
            border-top: none;
            border-left: none;
        }
        
        .timer-display {
            font-family: 'Cormorant Garamond', serif;
            font-weight: 700;
            font-size: 5rem;
            letter-spacing: -0.05em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 0.5rem;
        }
        /* Alignment Fix: Removed margin-bottom and made it display flex for perfect vertical centring with arrows */
        .session-nav-group {
            display: flex;
            align-items: center;
            justify-content: center;
            space-x-4: 1rem;
            margin-bottom: 2rem; /* Added spacing to the container instead */
        }
        .timer-label {
            font-size: 1.25rem;
            font-style: italic;
            opacity: 0.8;
            margin: 0; /* Ensures the label doesn't push the arrows out of alignment */
        }
        .button-group {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .control-button {
            padding: 0.75rem 2rem;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 9999px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(226, 217, 195, 0.2);
        }
        .start-button, .reset-button {
            color: #E2D9C3; /* Warm beige colour */
        }
        .start-button {
            background-color: #586F5C;
        }
        .start-button:hover:not(:disabled) {
            background-color: #6C8570;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .reset-button {
            background-color: #6C5B52;
        }
        .reset-button:hover:not(:disabled) {
            background-color: #8C756B;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .mode-button {
            background: none;
            border: none;
            padding: 0.5rem;
            cursor: pointer;
            transition: transform 0.2s;
            color: #E2D9C3;
            opacity: 0.7;
        }
        .mode-button:hover:not(:disabled) {
            opacity: 1;
            transform: scale(1.1);
        }

        /* Volume Slider Custom Styles (for Dark Academia look) */
        #volumeSlider {
            -webkit-appearance: none;
            appearance: none;
            background: #6C5B52;
            height: 8px;
            cursor: pointer;
        }
        #volumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #E2D9C3; /* Knob color */
            border: 2px solid #586F5C;
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        #volumeSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #E2D9C3;
            border: 2px solid #586F5C;
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        /* Modal specific styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal-content {
            background-color: #3C342E; /* Darker than container */
            border: 2px solid #586F5C;
            border-radius: 12px;
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
        .queue-item {
            background-color: rgba(60, 52, 46, 0.9);
            border-left: 4px solid;
            padding: 0.75rem;
            border-radius: 4px;
        }
        .work-border { border-left-color: #9F765A; } /* Brick Terracotta for work */
        .break-border { border-left-color: #586F5C; } /* Greenish for break */
        .long-break-border { border-left-color: #665a55; } /* Greyish for long break */
        
        /* Modal Add Task Buttons - Text colour fix */
        .add-task-btn {
            color: #E2D9C3 !important; /* Ensure modal button text is also warm beige */
        }

        @media (max-width: 640px) {
            .timer-display {
                font-size: 3.5rem;
            }
            .timer-container {
                padding: 1.5rem;
            }
            .control-button {
                padding: 0.5rem 1rem;
            }
            .button-group {
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="timer-container">
        <!-- Status and Title -->
        <h1 class="text-xl font-bold mb-4 opacity-80">The Scholar's Focus</h1>
        <p id="currentTaskDisplay" class="text-md font-style: italic mb-2 opacity-90 truncate w-full px-4">Loading Task...</p>

        <!-- Session Label (FIXED ALIGNMENT: Replaced class 'flex items-center space-x-4' with 'session-nav-group') -->
        <div class="session-nav-group">
            <button id="prevMode" class="mode-button" title="Previous Mode">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-left"><path d="m15 18-6-6 6-6"/></svg>
            </button>
            <span id="timerLabel" class="timer-label">Loading Session...</span>
            <button id="nextMode" class="mode-button" title="Next Mode">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-right"><path d="m9 18 6-6-6-6"/></svg>
            </button>
        </div>
        
        <!-- Timer display -->
        <div id="timerDisplay" class="timer-display">--:--</div>
        
        <!-- Control buttons -->
        <div class="button-group">
            <button id="startButton" class="control-button start-button">Start</button>
            <button id="resetButton" class="control-button reset-button">Reset</button>
            <button id="skipButton" class="control-button reset-button px-4 py-2" title="Skip Session/Next Queue Item">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-skip-forward h-5 w-5"><polygon points="5 4 15 12 5 20 5 4"/><line x1="19" x2="19" y1="5" y2="19"/></svg>
            </button>
        </div>

        <!-- Queue Button & Next Task Info -->
        <div class="mt-6 w-full px-4">
            <button id="queueButton" class="w-full control-button start-button !bg-[#586F5C] hover:!bg-[#6C8570] text-sm py-2">
                <span id="queueCount">Queue (0)</span> | <span id="nextTaskInfo">Manual Cycle</span>
            </button>
        </div>

        <!-- Volume Controls (NEW FEATURE) -->
        <div class="mt-4 w-full flex items-center justify-center space-x-3 text-sm opacity-90">
            <!-- Mute Button -->
            <button id="muteButton" class="mode-button p-2" title="Toggle Mute">
                <!-- Initial high volume icon, updated by JS -->
                <svg id="muteIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-2 h-5 w-5"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 0 0 1 0 14.14"/></svg>
            </button>

            <!-- Volume Slider -->
            <input type="range" id="volumeSlider" min="0" max="1" step="0.05" value="0.1" class="w-2/3 h-2 rounded-lg appearance-none cursor-pointer">
        </div>
    </div>

    <!-- Audio Elements for Background Music -->
    <audio id="workMusic" loop preload="auto" src="Pen Writing .mp3"></audio>
    <audio id="breakMusic" loop preload="auto" src="Bach Cello Suite No. 1, G Major, Prelude - Cooper Cannell.mp3"></audio>
    <audio id="longBreakMusic" loop preload="auto" src="The Dance Before - Nathan Moore.mp3"></audio>

    <!-- The Queue Modal -->
    <div id="queueModal" class="modal">
        <!-- MODIFICATION: Changed text-white to text-[#E2D9C3] to use off-white text color -->
        <div class="modal-content text-[#E2D9C3]"> 
            <h2 class="text-2xl font-bold mb-4 border-b border-gray-600 pb-2 flex justify-between items-center">
                Study Queue
                <button id="closeModalButton" class="text-gray-400 hover:text-white">&times;</button>
            </h2>

            <!-- Add Task Input -->
            <div class="mb-4">
                <input type="text" id="taskNameInput" placeholder="Enter task name (e.g., Chapter 3 Review)"
                        class="w-full p-2 rounded-lg bg-[#2C241E] border border-[#586F5C] text-white placeholder-gray-500 focus:outline-none focus:ring-1 focus:ring-[#586F5C]">
            </div>

            <!-- Add Task Buttons -->
            <div class="flex gap-2 mb-6 justify-center flex-wrap">
                <!-- Brick Terracotta button colour for work sessions -->
                <button data-type="work" class="add-task-btn control-button !bg-[#8a3024] text-white text-xs py-2 px-3 hover:!bg-[#8a392f]">
                    + 25m Focus
                </button>
                <button data-type="break" class="add-task-btn control-button !bg-[#586F5C] text-white text-xs py-2 px-3 hover:!bg-[#6C8570]">
                    + 5m Break
                </button>
                <button data-type="longBreak" class="add-task-btn control-button !bg-[#665a55] text-white text-xs py-2 px-3 hover:!bg-[#69605c]">
                    + 15m Rest
                </button>
            </div>

            <!-- Queue List -->
            <h3 class="text-lg font-semibold mb-2">Next Sessions:</h3>
            <div id="queueList" class="space-y-2 max-h-48 overflow-y-auto pr-2">
                <!-- Queue items will be inserted here -->
                <p id="queueEmptyMessage" class="text-sm text-gray-500 italic">Queue is currently empty.</p>
            </div>

            <div class="mt-6 flex justify-between">
                <!-- MODIFICATION: Changed text-white to text-[#E2D9C3] for off-white button text -->
                <button id="clearQueueButton" class="control-button !bg-[#6C5B52] text-[#E2D9C3] text-sm py-2 px-4 hover:!bg-[#8C756B]">
                    Clear All
                </button>
                <button id="runQueueButton" class="control-button start-button text-sm py-2 px-4">
                    Run Queue
                </button>
            </div>
        </div>
    </div>


    <script>
        // --- Configuration ---
        const WORK_DURATION = 25 * 60;
        const BREAK_DURATION = 5 * 60;
        const LONG_BREAK_DURATION = 15 * 60;
        const DURATION_MAP = {
            work: WORK_DURATION,
            break: BREAK_DURATION,
            longBreak: LONG_BREAK_DURATION,
        };
        const LABEL_MAP = {
            work: 'Focus Session',
            break: 'Short Break',
            longBreak: 'Long Rest',
        };
        const MUSIC_MAP = {}; 

        const INITIAL_STATE = {
            isRunning: false,
            sessionType: 'work', // 'work', 'break', 'longBreak'
            timeRemaining: WORK_DURATION,
            startTime: null, // UTC timestamp of start/resume
            currentTask: 'Manual Focus',
            queue: [], // [{ id: number, name: string, type: 'work' | 'break' | 'longBreak' }]
        };

        let localIntervalId = null;
        let currentState = { ...INITIAL_STATE };
        let previousSessionType = null; // Tracked locally for music logic
        
        // --- Volume State --- (NEW)
        let isMuted = false;
        // Start volume at 0.1, matching the initial slider value
        let lastVolume = 0.1; 

        // --- Standard Web Audio API Setup (Replacing Tone.js) ---
        let audioContext;

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        /**
         * Plays a simple beep sound using the Web Audio API.
         * @param {number} frequency - The frequency in Hz.
         * @param {number} duration - The duration in seconds.
         * @param {number} volume - The volume (gain) from 0 to 1.
         */
        function playBeep(frequency, duration, volume = 0.1) {
            initAudioContext();
            if (audioContext.state === 'suspended') {
                audioContext.resume().catch(e => console.error('AudioContext resume failed:', e));
                return;
            }

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // Connect oscillator to gain node, and gain node to destination
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Set properties
            oscillator.type = 'sine'; // Sine wave for a gentle tone
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            // Set volume with a quick fade-in/out
            const now = audioContext.currentTime;
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
            gainNode.gain.linearRampToValueAtTime(0, now + duration);

            // Start and stop the oscillator
            oscillator.start(now);
            oscillator.stop(now + duration);
        }

        // Initialize AudioContext on first user interaction (required by browsers)
        document.addEventListener('click', initAudioContext, { once: true });


        // --- DOM Elements ---
        const timerDisplay = document.getElementById('timerDisplay');
        const timerLabel = document.getElementById('timerLabel');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const skipButton = document.getElementById('skipButton');
        const prevModeButton = document.getElementById('prevMode');
        const nextModeButton = document.getElementById('nextMode');
        const queueButton = document.getElementById('queueButton');
        const currentTaskDisplay = document.getElementById('currentTaskDisplay');
        const queueModal = document.getElementById('queueModal');
        const closeModalButton = document.getElementById('closeModalButton');
        const taskNameInput = document.getElementById('taskNameInput');
        const queueList = document.getElementById('queueList');
        const queueEmptyMessage = document.getElementById('queueEmptyMessage');
        const queueCountDisplay = document.getElementById('queueCount');
        const nextTaskInfoDisplay = document.getElementById('nextTaskInfo');
        const runQueueButton = document.getElementById('runQueueButton');
        const clearQueueButton = document.getElementById('clearQueueButton');

        // NEW VOLUME ELEMENTS
        const volumeSlider = document.getElementById('volumeSlider');
        const muteButton = document.getElementById('muteButton');


        // --- UTILITY FUNCTIONS ---

        // NEW: Handles setting the volume and updating the mute icon
        function updateVolume(volume) {
            const vol = parseFloat(volume);
            
            // Set volume on all audio elements that are currently playing or paused
            Object.values(MUSIC_MAP).forEach(audio => {
                audio.volume = vol;
            });

            // Update slider position
            volumeSlider.value = vol;

            // Update mute button icon
            const currentVolume = vol;
            let iconHtml;
            
            // Use the correct icon based on volume level
            if (currentVolume == 0) {
                iconHtml = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-x h-5 w-5"><path d="M11 5 6 9 2 9 2 15 6 15 11 19z"/><line x1="22" x2="16" y1="9" y2="15"/><line x1="16" x2="22" y1="9" y2="15"/></svg>`;
            } else if (currentVolume < 0.5) {
                iconHtml = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-1 h-5 w-5"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 0 0 1 0 7.07"/></svg>`;
            } else {
                iconHtml = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-2 h-5 w-5"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 0 0 1 0 14.14"/></svg>`;
            }
            muteButton.innerHTML = iconHtml;
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // ðŸŸ¢ FIXED: playMusic now only updates volume/resumes if already playing (no reset)
        function playMusic(type) {
            const audio = MUSIC_MAP[type];
            if (audio) {
                // Only update volume, do NOT reset currentTime here.
                audio.volume = parseFloat(volumeSlider.value); 
                // Attempt to play/resume, catching the common promise error
                audio.play().catch(e => {
                    console.warn("Autoplay was prevented or resource failed to load. User interaction is required for audio playback.", e);
                });
            }
        }
        
        // ðŸš€ NEW: Dedicated function to stop ALL music and START the correct one from the beginning
        function startMusic(type) {
            // Stop all music first
            Object.values(MUSIC_MAP).forEach(audio => audio.pause());

            const audio = MUSIC_MAP[type];
            if (audio) {
                audio.volume = parseFloat(volumeSlider.value); 
                audio.currentTime = 0; // Ensure playback starts from the beginning
                audio.play().catch(e => {
                    console.warn("Autoplay was prevented or resource failed to load. User interaction is required for audio playback.", e);
                });
            }
        }

        function stopMusic() {
            Object.values(MUSIC_MAP).forEach(audio => {
                audio.pause();
                // We keep currentTime where it is on pause, so music resumes from the same spot if unpaused/restarted.
                // Resetting to 0 is only done in startMusic()
            });
        }


        function updateUI(state) {
            // Update Timer Display
            timerDisplay.textContent = formatTime(state.timeRemaining);
            timerLabel.textContent = LABEL_MAP[state.sessionType];
            currentTaskDisplay.textContent = `Task: ${state.currentTask}`;
            document.title = state.isRunning 
                ? `${formatTime(state.timeRemaining)} | ${state.currentTask}` 
                : 'The Scholar\'s Focus';

            // Update Start/Pause Button
            startButton.textContent = state.isRunning ? 'Pause' : 'Start';
            // Brick Terracotta colour for paused/work mode button
            const startClass = state.isRunning ? '!bg-[#8a3024]' : 'start-button'; 
            startButton.className = `control-button ${startClass}`;

            // Update Queue Info
            queueCountDisplay.textContent = `Queue (${state.queue.length})`;
            
            const isQueueActive = state.queue.length > 0;

            if (isQueueActive) {
                const nextItem = state.queue[0];
                const nextLabel = LABEL_MAP[nextItem.type].split(' ')[0];
                nextTaskInfoDisplay.textContent = `Next: ${nextItem.name} (${nextLabel})`;
                // Disable manual mode switch if queue is active
                prevModeButton.disabled = true;
                nextModeButton.disabled = true;
            } else {
                nextTaskInfoDisplay.textContent = 'Manual Cycle';
                // Only disable manual switch if running
                prevModeButton.disabled = state.isRunning;
                nextModeButton.disabled = state.isRunning;
            }

            // Highlight border based on session type
            const container = document.querySelector('.timer-container');
            // Brick Terracotta colour for work session border
            container.style.borderColor = state.sessionType === 'work' ? '#9f765a' : (state.sessionType === 'longBreak' ? '#665a55' : '#586F5C');

            // Re-render queue list in modal
            renderQueueList(state.queue);
        }

        function renderQueueList(queue) {
            queueList.innerHTML = '';
            if (queue.length === 0) {
                queueEmptyMessage.style.display = 'block';
                return;
            }
            queueEmptyMessage.style.display = 'none';

            queue.forEach((item, index) => {
                const itemDiv = document.createElement('div');
                const durationLabel = item.type === 'work' ? '25m' : (item.type === 'longBreak' ? '15m' : '5m');
                const borderClass = item.type === 'work' ? 'work-border' : (item.type === 'longBreak' ? 'long-break-border' : 'break-border');

                itemDiv.className = `queue-item flex justify-between items-center ${borderClass}`;
                itemDiv.innerHTML = `
                    <span class="text-sm font-medium mr-2">${index + 1}. ${item.name} <span class="opacity-70">(${durationLabel})</span></span>
                    <button data-id="${item.id}" class="delete-task-btn text-gray-400 hover:text-red-400 p-1 transition leading-none">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                    </button>
                `;
                queueList.appendChild(itemDiv);
            });

            // Re-attach delete listeners
            document.querySelectorAll('.delete-task-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const taskId = e.currentTarget.getAttribute('data-id');
                    handleDeleteTask(taskId);
                });
            });
        }

        // REPLACED: Tone.js alert with Web Audio API beep
        function playSessionAlert(type) {
            // Use different tones for work vs break transition alerts
            const frequency = type === 'work' ? 440 : 660; // A4 vs E5
            playBeep(frequency, 0.2, 0.1); 
        }

        // REPLACED: Tone.js end alert with a triple beep sequence
        function playEndAlert() {
             // Triple beep sequence for timer completion
            const freq1 = 200, freq2 = 400, freq3 = 800;
            const duration = 0.15;
            const delay = 0.2;
            const volume = 0.15;

            playBeep(freq1, duration, volume);
            setTimeout(() => playBeep(freq2, duration, volume), delay * 1000);
            setTimeout(() => playBeep(freq3, duration, volume), (delay * 2) * 1000);
        }

        // Timer calculation logic based on current state
        function calculateTimeRemaining(state) {
            if (!state.isRunning || !state.startTime) {
                return state.timeRemaining;
            }
            // Use current state's remaining time minus elapsed time since start
            const elapsedSeconds = Math.floor((Date.now() - state.startTime) / 1000);
            return Math.max(0, state.timeRemaining - elapsedSeconds);
        }

        // Local State Update Core
        function updateLocalState(updates) {
            const wasRunning = currentState.isRunning;
            const wasSessionType = currentState.sessionType;

            // Update state immediately
            currentState = { ...currentState, ...updates };
            
            // If we are starting/resuming, we must recalculate the true remaining time first
            currentState.timeRemaining = calculateTimeRemaining(currentState);

            // --- Music, Tick, and Transition Control ---
            if (currentState.isRunning) {
                // If starting or if the session type just changed, start music from beginning and alert
                if (!wasRunning || currentState.sessionType !== wasSessionType) {
                    // ðŸš€ USE NEW startMusic FUNCTION
                    startMusic(currentState.sessionType); 
                    playSessionAlert(currentState.sessionType); 
                }
                // Ensure local interval is running for smooth 1-second ticks
                if (!localIntervalId) {
                    startLocalTick();
                }
            } else {
                // If paused or reset, stop all sound (music and alert synths) and interval
                
                // (No need to release synths as they are gone)
                
                stopMusic();
                if (localIntervalId) {
                    clearInterval(localIntervalId);
                    localIntervalId = null;
                }
            }

            updateUI(currentState);
        }

        // --- TIMER CORE LOGIC ---

        function startLocalTick() {
            if (localIntervalId) clearInterval(localIntervalId);
            localIntervalId = setInterval(() => {
                // Update local UI state for smooth tick
                currentState.timeRemaining = Math.max(0, currentState.timeRemaining - 1);
                updateUI(currentState);

                // When local countdown hits 0, trigger stop/switch logic
                if (currentState.timeRemaining <= 0) {
                    clearInterval(localIntervalId);
                    localIntervalId = null;
                    
                    stopMusic();
                    playEndAlert(); // Use the new completion alert

                    // Prepare for transition
                    const updates = {
                        isRunning: false,
                        timeRemaining: 0,
                        startTime: null,
                    };
                    updateLocalState(updates);
                    
                    // Trigger the transition logic
                    startNextSession(currentState);
                }
            }, 1000);
        }
        
        // --- QUEUE & SESSION FLOW ---

        function startNextSession(state) {
            const queue = [...state.queue];

            if (queue.length > 0) {
                const nextItem = queue.shift();
                const nextDuration = DURATION_MAP[nextItem.type];
                
                const updates = {
                    isRunning: true,
                    sessionType: nextItem.type,
                    timeRemaining: nextDuration,
                    startTime: Date.now(),
                    currentTask: nextItem.name,
                    queue: queue, // Save the rest of the queue
                };
                updateLocalState(updates);
            } else {
                // Revert to default manual cycle when queue is empty
                const nextType = state.sessionType === 'work' ? 'break' : 'work';
                const nextDuration = DURATION_MAP[nextType];

                const updates = {
                    isRunning: false, // Stop running, wait for manual start
                    sessionType: nextType,
                    timeRemaining: nextDuration,
                    startTime: null,
                    currentTask: LABEL_MAP[nextType],
                };
                updateLocalState(updates);
            }
        }

        // --- EVENT HANDLERS ---

        startButton.addEventListener('click', () => {
            const isStarting = !currentState.isRunning;
            let updates = {
                isRunning: isStarting,
            };

            if (isStarting) {
                if (currentState.timeRemaining === 0) {
                    // If timer is at 0, initiate the next session logic
                    if (currentState.queue.length === 0) {
                        const nextType = currentState.sessionType === 'work' ? 'break' : 'work';
                        updates = {
                            sessionType: nextType,
                            timeRemaining: DURATION_MAP[nextType],
                            currentTask: LABEL_MAP[nextType],
                            isRunning: true,
                            startTime: Date.now(),
                        };
                    } else {
                            // If queue exists but is paused at 0, start the next queue item
                            startNextSession(currentState);
                            return; // Exit as startNextSession handles the update
                    }
                } else {
                    // Starting/Resuming: record the current time as the start point
                    updates.startTime = Date.now();
                    updates.timeRemaining = currentState.timeRemaining; // Use current remaining time
                }
            } else {
                // Pausing: reset start time and lock remaining time
                updates.startTime = null;
                updates.timeRemaining = calculateTimeRemaining(currentState);
            }

            updateLocalState(updates);
        });

        resetButton.addEventListener('click', () => {
            const currentDuration = DURATION_MAP[currentState.sessionType];
            const updates = {
                isRunning: false,
                timeRemaining: currentDuration,
                startTime: null,
            };
            updateLocalState(updates);
        });

        skipButton.addEventListener('click', () => {
            // Trigger a clean stop and then transition to the next state
            const updates = {
                isRunning: false,
                timeRemaining: 0,
                startTime: null,
            };
            updateLocalState(updates);
            // Manually initiate the next session switch
            startNextSession(currentState);
        });

        // --- MANUAL MODE SWITCHING ---

        function handleModeSwitch(direction) {
            if (currentState.isRunning || currentState.queue.length > 0) return;

            const modes = ['work', 'break', 'longBreak'];
            const currentIndex = modes.indexOf(currentState.sessionType);
            let newIndex = currentIndex;

            if (direction === 'next') {
                newIndex = (currentIndex + 1) % modes.length;
            } else if (direction === 'prev') {
                newIndex = (currentIndex - 1 + modes.length) % modes.length;
            }

            const newType = modes[newIndex];
            updateLocalState({
                sessionType: newType,
                timeRemaining: DURATION_MAP[newType],
                currentTask: LABEL_MAP[newType],
                isRunning: false,
                startTime: null,
            });
        }

        nextModeButton.addEventListener('click', () => handleModeSwitch('next'));
        prevModeButton.addEventListener('click', () => handleModeSwitch('prev'));


        // --- QUEUE HANDLERS ---
        
        queueButton.addEventListener('click', () => {
            queueModal.style.display = 'flex';
        });

        closeModalButton.addEventListener('click', () => {
            queueModal.style.display = 'none';
        });

        document.querySelectorAll('.add-task-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const type = e.currentTarget.getAttribute('data-type');
                const taskName = taskNameInput.value.trim() || LABEL_MAP[type];
                
                const newTask = {
                    id: Date.now() + Math.random(), // Simple unique ID
                    name: taskName,
                    type: type,
                };
                
                const newQueue = [...currentState.queue, newTask];
                updateLocalState({ queue: newQueue });

                // Clear input after adding
                taskNameInput.value = '';
                // Keep the modal open
            });
        });

        function handleDeleteTask(taskId) {
            const newQueue = currentState.queue.filter(task => task.id != taskId);
            updateLocalState({ queue: newQueue });
        }

        clearQueueButton.addEventListener('click', () => {
            updateLocalState({ queue: [] });
        });

        runQueueButton.addEventListener('click', () => {
            if (currentState.queue.length > 0) {
                // If currently running, the next session will start the queue automatically.
                // If paused or reset, start the next session immediately.
                if (!currentState.isRunning || currentState.timeRemaining === 0) {
                    startNextSession(currentState);
                } else {
                    // If timer is already running, just close the modal.
                }
                queueModal.style.display = 'none';
            }
        });

        // --- INITIALIZATION ---
        
function init() {
    // Map audio elements to MUSIC_MAP
    MUSIC_MAP.work = document.getElementById('workMusic');
    MUSIC_MAP.break = document.getElementById('breakMusic');
    MUSIC_MAP.longBreak = document.getElementById('longBreakMusic');
    
    // Set initial volume
    updateVolume(volumeSlider.value);

    // Attach volume control listeners
    volumeSlider.addEventListener('input', (e) => {
        const newVolume = parseFloat(e.target.value);
        
        // ðŸŸ¢ FIX: Only call updateVolume, do not restart music on volume change
        updateVolume(newVolume); 
        
        lastVolume = newVolume; // Save last volume
        isMuted = newVolume === 0;
        
        // We only explicitly start music if we go from 0 volume (effectively muted) 
        // to a positive volume while the session is running.
        if (newVolume > 0 && currentState.isRunning && isMuted) {
            playMusic(currentState.sessionType); // Use playMusic to resume from current position
        } else if (newVolume === 0) {
             // If volume is set to 0 via slider, stop music immediately
            stopMusic(); 
        }
        // If volume is changed from non-zero to non-zero, the audio.volume property 
        // is updated by updateVolume(), and playback continues uninterrupted.
    });

    muteButton.addEventListener('click', () => {
        if (isMuted) {
            // Unmute
            const newVolume = lastVolume > 0 ? lastVolume : 0.1;
            updateVolume(newVolume);
            isMuted = false;
            
            // If the timer is running, resume the music playback on unmute.
            if (currentState.isRunning) {
                playMusic(currentState.sessionType); 
            }
        } else {
            // Mute
            lastVolume = parseFloat(volumeSlider.value); // Save current volume before muting
            updateVolume(0);
            isMuted = true;
            stopMusic(); // Stop music immediately on mute
        }
    });

    // Set initial state
    updateLocalState({});
}

window.onload = init;
    </script>
</body>
</html>
